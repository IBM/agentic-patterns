# MCP Protocol and Security - Current State

*  MCP server acts as a bridge between AI agents and various external APIs, databases, or software – allowing the AI to perform actions or retrieve data via high-level instructions. 

* A distinctive characteristic of MCP's security architecture is its explicit stance that it "cannot enforce these security principles at the protocol level" and "does not define or mandate specific authentication and authorization mechanisms". This means that unlike many other API protocols that standardize methods such as OAuth, API keys, or token-based authentication, _MCP defers these specifics to the implementation layer_. Instead, the protocol provides general guidelines, urging implementers to build robust consent and authorization flows, offer clear documentation of security implications, implement appropriate access controls, and adhere to general security best practices in their integrations. [mcp spec](https://modelcontextprotocol.io/specification/2025-03-26)   
* This means that the Host (LLM application) bears primary responsibility for obtaining explicit user consent before exposing user data or invoking tools, and for protecting that user data. Concurrently, the MCP Server is accountable for the secure handling of the data it processes and the safe execution of the tools it provides. The protocol itself functions more as a guiding set of principles rather than a prescriptive security enforcement layer.
* This architectural approach introduces a notable shift in the traditional concept of a "trust boundary." MCP, by not mandating protocol-level authentication and authorization, effectively decentralizes this trust boundary. While the Host application is obligated to obtain user consent, the actual authentication. If an MCP Host application employs a weak method to authenticate to an MCP Server, or if the Server itself has inadequate internal authorization controls, the entire system becomes vulnerable, even if other components are diligently secured. This absence of a standardized, enforced trust boundary at the protocol level increases the complexity of securing the overall ecosystem and makes it challenging to ensure a consistent security posture across diverse MCP implementations. 
* _each tool invocation and data exposure to specific servers._ Transport like SSO, which aims for users to bring their "own suite of pre-authenticated tools" and manage "profiles" of MCP Servers. 


## Key Challenges

- **Unauthorized Access (Lack of Auth):**  MCP endpoints (/sse endpoint or /mcp) could be exposed on a network, an attacker could directly connect and invoke tools if no access control is enforced.
- **Prompt Injection Attacks:** Because MCP involves AI agents interpreting instructions and deciding which tools to call, a prompt injection is a novel threat. An attacker (or malicious user) could craft input to the AI model that tricks it into invoking tools in unintended ways. For instance, if an AI is instructed with a cleverly crafted prompt, it might execute a tool action that the real user did not intend – such as deleting data or sending sensitive info elsewhere. This was demonstrated by research where malicious commands hidden in tool descriptions or user inputs could hijack the AI’s decision-making
[arsturn.com](https://www.arsturn.com/blog/detecting-preventing-vulnerabilities-mcp-server-configurations#:~:text=2,making%20abilities)
- **Tool Description Tampering ("Rug Pull"):** MCP clients rely on tool descriptions (metadata about what each tool does) to decide how to use them. Attackers may attempt to tamper with these descriptions, especially in community or shared tool repositories, to insert malicious behavior. For example, a benign tool might later be altered (pulled out from under the user, hence “rug pull”) so that its description or implementation includes a hidden destructive command. If the MCP server loads such a tool update, the AI could be misled into executing harmful actions [arsturn.com](https://www.arsturn.com/blog/detecting-preventing-vulnerabilities-mcp-server-configurations#:~:text=3,often%20occurs%20without%20user%20consent).
- **Excessive Permission Scope:** If an MCP server or the tokens it uses are granted overly broad permissions, the impact of any compromise is magnified. For instance, if an MCP server integration with a cloud provider is given admin-level API keys, then any breach of the MCP server could lead to a complete compromise of the cloud account. Arsturn’s security analysis notes that many MCP setups request broad scopes, increasing the risk of sensitive data exposure [arsturn.com](https://www.arsturn.com/blog/detecting-preventing-vulnerabilities-mcp-server-configurations#:~:text=4,need%20for%20careful%20permissions%20management). Most `ask-XX` apps usually need permission to answer different kinds of questions and often avoid least-privileged access practice, and that can be a serious threat. 

- **Code Injection & Execution Attacks:** Some MCP servers might allow executing arbitrary code or shell commands as part of tool implementations (for example,wxO allows adding tools using a Python script). If such functionality is present, it becomes an attack surface. A malicious input could exploit this by injecting code. A specific caution in this realm: avoid using constructs like eval() on untrusted input within tool implementations[arsturn.com](https://www.arsturn.com/blog/detecting-preventing-vulnerabilities-mcp-server-configurations#:~:text=3). Doing so can lead to remote code execution by an attacker.

- **Denial of Service (DoS):** Like any server, MCP servers can be subject to DoS attacks. An attacker might flood the server with connection attempts or heavy tool requests, exhausting resources. In the context of MCP, an attacker could, for example, repeatedly trigger a tool that performs an expensive operation, or open many SSE streams to exhaust connection limits. Rate limiting and monitoring are important countermeasures here [github.com](https://github.com/nahmanmate/better-auth-mcp-server#:~:text=,Monitoring).


## Novel Attack Surface for MCP 


Beyond traditional API vulnerabilities like Broken Object Level Authorization (BOLA) [API 1:2023], Broken Authentication [API 2:2023], Broken Object Property Level Authorization (BOPLA) [API 3:2023], Unrestricted Resource Consumption [API 4:2023], Broken Function Level Authorization (BFLA) [API 5:2023]and Security Misconfiguration [API 8:2023], MCP's unique architecture introduces several novel attack vectors:

- **Tool Poisoning Attacks:** MCP servers directly load tool descriptions into an AI model's operational context. Attackers can embed hidden, malicious commands within these descriptions. When the LLM processes these descriptions, it can inadvertently execute the malicious commands.   

*  **Puppet Attacks:** Tools do not have a unique identifier in MCP, which allows attackers to create malicious tools with names identical or highly similar to legitimate ones. An unsuspecting user's AI assistant might then invoke the malicious tool instead of the intended one, leading to unauthorized actions. For example, an attacker could introduce a fake "backup_files" tool that exfiltrates data instead of backing it up. For example, I have a tool called `get_data_from_db2` with description that match the name but in the body it actually delete the database.   

* **Rug Pull Attacks:** This involves attackers setting up malicious MCP servers, initiating an attack, and then quickly severing the connection to hide evidence and complicate forensic analysis. This makes it difficult for security teams to trace the source of a breach.   

* **Exploitation via Malicious External Resources:** The dynamic nature of MCP allows LLMs to retrieve external resources through one tool, which might contain hidden commands intended to prompt the AI to extract sensitive files or perform other malicious actions through another connected tool. This chain of interaction creates a sophisticated attack path.   

* **Insecure Authentication (MCP-specific):** The lack of robust, mandated authentication mechanisms at the MCP protocol level allows attackers to introduce rogue servers that mimic legitimate services. Users unknowingly connecting their AI assistants to these fake servers can lead to interception and collection of sensitive information. This is a direct consequence of MCP's non-prescriptive AuthZ/N model.   

* **Overly Broad Permissions:** MCP tools often request overly broad permissions, escalating the potential damage if the tool or its connection is compromised. A connector might unnecessarily request full access to a user's cloud storage, vastly amplifying security risks if breached.   

* **Orchestrated Exploits via Multiple Connectors:** Attackers can manipulate interactions between multiple MCP connectors to orchestrate sophisticated exploits. An AI assistant retrieving a document via one connector might find hidden instructions within it to immediately use another connector to upload sensitive internal files to an attacker-controlled public cloud storage.   

* **Shadow MCP Servers:** Organizations may deploy internal MCP servers that operate outside established security controls and monitoring frameworks. These "shadow" servers create blind spots, making them attractive targets for attackers and posing significant risks to the organization's security posture.   

* **Supply Chain Risks:** MCP servers contain executable code, making them vulnerable to supply chain attacks. Users must only use trusted MCP servers. Developers must sign components, implement Static Application Security Testing (SAST) and Software Composition Analysis (SCA) in their pipelines to identify and fix vulnerabilities in their code and dependencies. If attackers compromise the source code of an MCP component, they can potentially compromise the users of that component.   

* **Unauthorized Command Execution/Injection:** MCP servers can execute arbitrary code. Depending on how the MCP client passes information to the server and how the server is implemented, command execution functionality may be vulnerable to command injection vulnerabilities. This risk is particularly high if input data is not properly sanitized before being used as arguments for functions that execute commands.


## How MCP Integration Differs from Traditional APIs


|Aspect | Traditional API Integration | MCP (AI-Driven) Integration|
|-- | -- | --|
|Integration Model | App developer pre-selects which third-party APIs to support. Users are limited to the integrations the app provides. Each new integration requires development effort. | User-driven and flexible: any service with an MCP server can be integrated on the fly. Users bring their own suite of pre-authenticated tools to the application, not limited by developer choices.|
|Authentication Flows | Each application separately implements auth (OAuth, API keys, etc.) for each integration. Users may need to authenticate separately with each service in each app. SSO between apps is not guaranteed. | Unified or centralized auth flows can be employed. For example, a single Single Sign-On (SSO) mechanism can grant an AI agent access to multiple tools in one go. The MCP specification itself builds on OAuth 2.1 flows (with PKCE) to allow agents to securely obtain tokens on a user’s behalf.|
|Scope & Permissions | Typically coarse-grained scopes per API (often endpoint- or API-level). Permissions are defined per service (e.g. “read all emails” or “edit contacts”). Consent and scopes are managed per integration, often with broad access if granted. | Fine-grained, function-level scopes are needed. Each tool exposed by an MCP server can correspond to a specific action (function) requiring distinct permission. MCP servers must define and enforce scopes for each tool or capability. Users should be shown consent screens to approve exactly which tool actions an AI agent may invoke.|
|Security Considerations | Well-understood web API threats: unauthorized API calls (mitigated by tokens/API keys), input injection (SQLi/XSS), etc. Industry best practices (OAuth, HTTPS, input validation) are established to mitigate these. | New threat vectors arise due to the AI tool context. For instance, prompt injection attacks can trick an LLM into issuing unintended tool commands, or maliciously altered tool descriptions (“rug pull” attacks) can insert hidden dangerous instructions. Overly broad tool permissions or scopes can expose sensitive data if not limited. Additionally, integrating enterprise identity systems is non-trivial – MCP’s auth model assumes the MCP server itself issues tokens, complicating use of external SSO/IdP systems.|
|Developer Effort & Support | Mature support: Many frameworks and libraries exist for standard auth (Auth0, OAuth libraries, API gateways). Developers are generally familiar with implementing these, and identity providers (e.g. Okta, Google) are easily integrated for user login to apps. | Emerging ecosystem: Implementers must understand the evolving MCP spec and tool semantics. OAuth 2.1 compliance (PKCE, dynamic client registration) is required but not fully supported by all existing MCP server implementations. Builders often have to extend or customize open-source MCP servers for enterprise-grade auth, which can incur maintenance overhead.|

